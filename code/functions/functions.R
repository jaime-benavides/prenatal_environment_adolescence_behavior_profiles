# Supporting functions


# only works with lm right now  (jacob's code)
compare_model_imput <- function(model,
                                model_imput) {
  
  print(summary(model))
  print(summary(mice::pool(model_imput), conf.int = T) )
  
  Nimputs <- length(model_imput$analyses)
  cols <- c(paste0("grey", 50:(49+Nimputs)), "red")
  
  model_list <- list(model)  
  names(model_list) <- "base_model"
  
  model_imput_list <- lapply(model_imput$analyses, function(x) x)
  names(model_imput_list) <- lapply(1:Nimputs, function(x) paste0("imput_", x))
  
  all_models <- c(model_list, model_imput_list)
  
  plot <- dotwhisker::dwplot(all_models, ci = 0.95, dodge_size = 0.7) + 
    scale_colour_manual(values = cols) + theme_bw() + 
    xlim(-0.75, 0.75) +
    labs(title = as.character(formula(all_models[[1]]))[2])
  
  print(plot)
} 


print_patterns_loc <- function(pats, colgroups = NULL, n = 1:6, pat_type = "pat", 
                               title = "", size_line = 1, size_point = 1, 
                               hline = NULL, ylim_min = -0.5, ylim_max = 1) 
{
  if (!is.null(colgroups)) {
    colgroups <- colgroups %>% dplyr::rename(chem = !!names(colgroups)[1])
  }
  else {
    colgroups <- data.frame(chem = rownames(pats), group = "1")
  }
  if (n > ncol(pats)) 
    n <- ncol(pats)
  grouping <- names(colgroups)[2]
  colnames(pats) <- paste0(pat_type, stringr::str_pad(1:ncol(pats), 
                                                      width = 2, pad = "0", side = "left"))
  pats.df <- pats %>% tibble::as_tibble() %>% dplyr::mutate(chem = colgroups[[1]]) %>% 
    tidyr::pivot_longer(-chem, names_to = "pattern", values_to = "loading") %>% 
    dplyr::right_join(., colgroups, by = "chem")
  pats.df$chem <- factor(as.character(pats.df$chem), levels = unique(as.character(pats.df$chem)))
  loadings <- pats.df %>% dplyr::filter(pattern %in% paste0(pat_type, 
                                                            stringr::str_pad(n, width = 2, pad = "0", side = "left"))) %>% 
    ggplot(aes(x = chem, y = loading, color = !!sym(grouping))) + 
    geom_point(size = size_point) + geom_segment(aes(yend = 0, xend = chem), size = size_line) + 
    facet_wrap(~pattern) + theme_bw() + theme(legend.position = "bottom", legend.text = element_text(size=12), legend.title = element_text(size=14),
                                              axis.text.x = element_text(angle = 45, hjust = 1, size = 16), strip.background = element_rect(fill = "white"), 
                                              axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y = element_text(size = 16)) + 
    geom_hline(yintercept = 0, size = 0.2) +
    geom_hline(yintercept = 0.3, size = 0.2, linetype=2) + 
    ylim(ylim_min,ylim_max)
  loadings
}

# solution from https://stackoverflow.com/questions/35186694/r-left-outer-join-with-0-fill-instead-of-na-while-preserving-valid-nas-in-left
left_join0 <- function(x, y, fill = 0L, ...){
  z <- dplyr::left_join(x, y, ...)
  new_cols <- setdiff(names(z), names(x))
  z <- tidyr::replace_na(z, setNames(as.list(rep(fill, length(new_cols))), new_cols))
  z
}

# summarize frequentist results  (from Robbie)
summarise_mod_freq = function(mod.freq){
  
  rr.mean = exp(mod.freq$coefficients)
  rr.uncertainty = exp(confint.default(mod.freq))
  dat.results.freq = data.frame(rr_2p5=round(rr.uncertainty[,1],2),
                                rr_mean=round(rr.mean,2),
                                rr_97p5=round(rr.uncertainty[,2], 2))
  return(dat.results.freq)
}

#github: cbergmeir/tsExpKit/R/normalizeData.R
normalizeData <- function(x, type="norm") {
  
  if(!is.list(type))
    type <- computeNormalizationParameters(x, type)
  
  res <- normalizeDataWithParams(x, type, norm=TRUE) 
  
  res
}

#' Revert data normalization.
#'
#' Column-wise normalization of the input matrix is reverted.
#' 
#' @param x input data
#' @param normParams the parameters generated by an earlier call to \code{normalizeData} that will be used for reverting normalization
#' @return column-wise reverse-normalized input
#' @export
denormalizeData <- function(x, normParams)
  normalizeDataWithParams(x, normParams, norm=FALSE) 

# @export
computeNormalizationParameters <- function(x, type="norm") {
  
  x <- as.matrix(x)
  
  params <- list()
  
  if(type == "0_1") {
    
    colMaxima <- NULL
    colMinima <- NULL
    
    for(i in 1:ncol(x)) {
      
      colMaxima <- c(colMaxima, max(x[,i], na.rm = TRUE))
      colMinima <- c(colMinima, min(x[,i], na.rm = TRUE))
      
    }
    
    params$colMaxima <- colMaxima
    params$colMinima <- colMinima
    
  } else if(type== "center") {
    
    colMeans <- NULL
    
    for(i in 1:ncol(x)) {
      
      colMeans <- c(colMeans, mean(x[,i], na.rm = TRUE))
      
    }
    
    params$colMeans <- colMeans
    
  } else {
    
    type="norm"
    
    colMeans <- NULL
    colSds <- NULL
    
    for(i in 1:ncol(x)) {
      
      colMeans <- c(colMeans, mean(x[,i], na.rm = TRUE))
      colSds <- c(colSds, sd(x[,i], na.rm = TRUE))
      
    }
    
    params$colMeans <- colMeans
    params$colSds <- colSds
    
  }
  
  params$type <- type
  params
}  

# @export
normalizeDataWithParams <- function(x, normParams, norm=TRUE) {
  
  x <- as.matrix(x)
  
  res <- NULL
  
  type <- normParams$type
  
  if(type == "0_1") {
    
    for(i in 1:ncol(x)) {
      
      colMax <- normParams$colMaxima[i]
      colMin <- normParams$colMinima[i]
      
      if(norm) {
        if((colMax - colMin) != 0)
          res <- cbind(res, (x[,i] - colMin) / (colMax - colMin))
        else 
          res <- cbind(res, (x[,i]))
      } else
        res <- cbind(res, x[,i] * (colMax - colMin) + colMin)
      
    }    
    
  } else if(type== "center") {
    
    for(i in 1:ncol(x)) {
      
      colMean <- normParams$colMeans[i]
      
      if(norm)
        res <- cbind(res, x[,i] - colMean)
      else  
        res <- cbind(res, x[,i] + colMean)
      
    }
    
  } else if(type== "norm") {
    
    for(i in 1:ncol(x)) {
      
      colMean <- normParams$colMeans[i]
      colSd <- normParams$colSds[i]
      
      if(norm) {
        if(colSd != 0)
          res <- cbind(res, (x[,i] - colMean) / colSd )
        else
          res <- cbind(res, (x[,i] - colMean))
      } else
        res <- cbind(res, x[,i] * colSd + colMean)
    }
    
  }
  
  attr(res, "normParams") <- normParams
  res
  
}
